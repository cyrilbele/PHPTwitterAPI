<?php
/**
 * TweetsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Twitter API v2
 *
 * Twitter API v2 available endpoints
 *
 * OpenAPI spec version: 2.60
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.36
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TweetsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TweetsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addOrDeleteRules
     *
     * Add/Delete rules
     *
     * @param  \Swagger\Client\Model\AddOrDeleteRulesRequest $body body (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AddOrDeleteRulesResponse
     */
    public function addOrDeleteRules($body, $dry_run = null)
    {
        list($response) = $this->addOrDeleteRulesWithHttpInfo($body, $dry_run);
        return $response;
    }

    /**
     * Operation addOrDeleteRulesWithHttpInfo
     *
     * Add/Delete rules
     *
     * @param  \Swagger\Client\Model\AddOrDeleteRulesRequest $body (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AddOrDeleteRulesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addOrDeleteRulesWithHttpInfo($body, $dry_run = null)
    {
        $returnType = '\Swagger\Client\Model\AddOrDeleteRulesResponse';
        $request = $this->addOrDeleteRulesRequest($body, $dry_run);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AddOrDeleteRulesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addOrDeleteRulesAsync
     *
     * Add/Delete rules
     *
     * @param  \Swagger\Client\Model\AddOrDeleteRulesRequest $body (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addOrDeleteRulesAsync($body, $dry_run = null)
    {
        return $this->addOrDeleteRulesAsyncWithHttpInfo($body, $dry_run)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addOrDeleteRulesAsyncWithHttpInfo
     *
     * Add/Delete rules
     *
     * @param  \Swagger\Client\Model\AddOrDeleteRulesRequest $body (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addOrDeleteRulesAsyncWithHttpInfo($body, $dry_run = null)
    {
        $returnType = '\Swagger\Client\Model\AddOrDeleteRulesResponse';
        $request = $this->addOrDeleteRulesRequest($body, $dry_run);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addOrDeleteRules'
     *
     * @param  \Swagger\Client\Model\AddOrDeleteRulesRequest $body (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addOrDeleteRulesRequest($body, $dry_run = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addOrDeleteRules'
            );
        }

        $resourcePath = '/2/tweets/search/stream/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dry_run !== null) {
            $queryParams['dry_run'] = ObjectSerializer::toQueryValue($dry_run, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTweet
     *
     * Creation of a Tweet
     *
     * @param  \Swagger\Client\Model\TweetCreateRequest $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TweetCreateResponse
     */
    public function createTweet($body)
    {
        list($response) = $this->createTweetWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createTweetWithHttpInfo
     *
     * Creation of a Tweet
     *
     * @param  \Swagger\Client\Model\TweetCreateRequest $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TweetCreateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTweetWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\TweetCreateResponse';
        $request = $this->createTweetRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TweetCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTweetAsync
     *
     * Creation of a Tweet
     *
     * @param  \Swagger\Client\Model\TweetCreateRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTweetAsync($body)
    {
        return $this->createTweetAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTweetAsyncWithHttpInfo
     *
     * Creation of a Tweet
     *
     * @param  \Swagger\Client\Model\TweetCreateRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTweetAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\TweetCreateResponse';
        $request = $this->createTweetRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTweet'
     *
     * @param  \Swagger\Client\Model\TweetCreateRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTweetRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createTweet'
            );
        }

        $resourcePath = '/2/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTweetById
     *
     * Tweet delete by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TweetDeleteResponse
     */
    public function deleteTweetById($id)
    {
        list($response) = $this->deleteTweetByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteTweetByIdWithHttpInfo
     *
     * Tweet delete by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TweetDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTweetByIdWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TweetDeleteResponse';
        $request = $this->deleteTweetByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TweetDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTweetByIdAsync
     *
     * Tweet delete by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTweetByIdAsync($id)
    {
        return $this->deleteTweetByIdAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTweetByIdAsyncWithHttpInfo
     *
     * Tweet delete by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTweetByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TweetDeleteResponse';
        $request = $this->deleteTweetByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTweetById'
     *
     * @param  \Swagger\Client\Model\TweetId $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTweetByIdRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTweetById'
            );
        }

        $resourcePath = '/2/tweets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetById
     *
     * Tweet lookup by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsIdResponse
     */
    public function findTweetById($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetByIdWithHttpInfo($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetByIdWithHttpInfo
     *
     * Tweet lookup by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetByIdWithHttpInfo($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsIdResponse';
        $request = $this->findTweetByIdRequest($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetByIdAsync
     *
     * Tweet lookup by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetByIdAsync($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetByIdAsyncWithHttpInfo($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetByIdAsyncWithHttpInfo
     *
     * Tweet lookup by Tweet ID
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetByIdAsyncWithHttpInfo($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsIdResponse';
        $request = $this->findTweetByIdRequest($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetById'
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findTweetByIdRequest($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling findTweetById'
            );
        }

        $resourcePath = '/2/tweets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetsById
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  \Swagger\Client\Model\TweetId[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsResponse
     */
    public function findTweetsById($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetsByIdWithHttpInfo($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetsByIdWithHttpInfo
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  \Swagger\Client\Model\TweetId[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetsByIdWithHttpInfo($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsResponse';
        $request = $this->findTweetsByIdRequest($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetsByIdAsync
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  \Swagger\Client\Model\TweetId[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsByIdAsync($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetsByIdAsyncWithHttpInfo($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetsByIdAsyncWithHttpInfo
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  \Swagger\Client\Model\TweetId[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsByIdAsyncWithHttpInfo($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsResponse';
        $request = $this->findTweetsByIdRequest($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetsById'
     *
     * @param  \Swagger\Client\Model\TweetId[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findTweetsByIdRequest($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findTweetsById'
            );
        }

        $resourcePath = '/2/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, 'csv', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($ids, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetsThatQuoteATweet
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsIdQuoteTweetsResponse
     */
    public function findTweetsThatQuoteATweet($id, $max_results = '10', $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetsThatQuoteATweetWithHttpInfo($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetsThatQuoteATweetWithHttpInfo
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsIdQuoteTweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetsThatQuoteATweetWithHttpInfo($id, $max_results = '10', $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsIdQuoteTweetsResponse';
        $request = $this->findTweetsThatQuoteATweetRequest($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsIdQuoteTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetsThatQuoteATweetAsync
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsThatQuoteATweetAsync($id, $max_results = '10', $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetsThatQuoteATweetAsyncWithHttpInfo($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetsThatQuoteATweetAsyncWithHttpInfo
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsThatQuoteATweetAsyncWithHttpInfo($id, $max_results = '10', $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsIdQuoteTweetsResponse';
        $request = $this->findTweetsThatQuoteATweetRequest($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetsThatQuoteATweet'
     *
     * @param  \Swagger\Client\Model\TweetId $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findTweetsThatQuoteATweetRequest($id, $max_results = '10', $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling findTweetsThatQuoteATweet'
            );
        }

        $resourcePath = '/2/tweets/{id}/quote_tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'csv', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRules
     *
     * Rules lookup
     *
     * @param  \Swagger\Client\Model\RuleId[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#x27;next_token&#x27; returned in a request to paginate through results. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RulesLookupResponse
     */
    public function getRules($ids = null, $max_results = '1000', $pagination_token = null)
    {
        list($response) = $this->getRulesWithHttpInfo($ids, $max_results, $pagination_token);
        return $response;
    }

    /**
     * Operation getRulesWithHttpInfo
     *
     * Rules lookup
     *
     * @param  \Swagger\Client\Model\RuleId[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#x27;next_token&#x27; returned in a request to paginate through results. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RulesLookupResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRulesWithHttpInfo($ids = null, $max_results = '1000', $pagination_token = null)
    {
        $returnType = '\Swagger\Client\Model\RulesLookupResponse';
        $request = $this->getRulesRequest($ids, $max_results, $pagination_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RulesLookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRulesAsync
     *
     * Rules lookup
     *
     * @param  \Swagger\Client\Model\RuleId[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#x27;next_token&#x27; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesAsync($ids = null, $max_results = '1000', $pagination_token = null)
    {
        return $this->getRulesAsyncWithHttpInfo($ids, $max_results, $pagination_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRulesAsyncWithHttpInfo
     *
     * Rules lookup
     *
     * @param  \Swagger\Client\Model\RuleId[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#x27;next_token&#x27; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesAsyncWithHttpInfo($ids = null, $max_results = '1000', $pagination_token = null)
    {
        $returnType = '\Swagger\Client\Model\RulesLookupResponse';
        $request = $this->getRulesRequest($ids, $max_results, $pagination_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRules'
     *
     * @param  \Swagger\Client\Model\RuleId[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#x27;next_token&#x27; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRulesRequest($ids = null, $max_results = '1000', $pagination_token = null)
    {

        $resourcePath = '/2/tweets/search/stream/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($ids)) {
            $ids = ObjectSerializer::serializeCollection($ids, 'multi', true);
        }
        if ($ids !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($ids, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTweetsFirehoseStream
     *
     * Firehose stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamingTweetResponse
     */
    public function getTweetsFirehoseStream($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->getTweetsFirehoseStreamWithHttpInfo($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation getTweetsFirehoseStreamWithHttpInfo
     *
     * Firehose stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamingTweetResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTweetsFirehoseStreamWithHttpInfo($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\StreamingTweetResponse';
        $request = $this->getTweetsFirehoseStreamRequest($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamingTweetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTweetsFirehoseStreamAsync
     *
     * Firehose stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTweetsFirehoseStreamAsync($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->getTweetsFirehoseStreamAsyncWithHttpInfo($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTweetsFirehoseStreamAsyncWithHttpInfo
     *
     * Firehose stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTweetsFirehoseStreamAsyncWithHttpInfo($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\StreamingTweetResponse';
        $request = $this->getTweetsFirehoseStreamRequest($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTweetsFirehoseStream'
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTweetsFirehoseStreamRequest($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'partition' is set
        if ($partition === null || (is_array($partition) && count($partition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $partition when calling getTweetsFirehoseStream'
            );
        }

        $resourcePath = '/2/tweets/firehose/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($backfill_minutes !== null) {
            $queryParams['backfill_minutes'] = ObjectSerializer::toQueryValue($backfill_minutes, 'int32');
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition, 'int32');
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTweetsSample10Stream
     *
     * Sample 10% stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsSample10StreamResponse
     */
    public function getTweetsSample10Stream($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->getTweetsSample10StreamWithHttpInfo($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation getTweetsSample10StreamWithHttpInfo
     *
     * Sample 10% stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsSample10StreamResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTweetsSample10StreamWithHttpInfo($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSample10StreamResponse';
        $request = $this->getTweetsSample10StreamRequest($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsSample10StreamResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTweetsSample10StreamAsync
     *
     * Sample 10% stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTweetsSample10StreamAsync($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->getTweetsSample10StreamAsyncWithHttpInfo($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTweetsSample10StreamAsyncWithHttpInfo
     *
     * Sample 10% stream
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTweetsSample10StreamAsyncWithHttpInfo($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSample10StreamResponse';
        $request = $this->getTweetsSample10StreamRequest($partition, $backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTweetsSample10Stream'
     *
     * @param  int $partition The partition number. (required)
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTweetsSample10StreamRequest($partition, $backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'partition' is set
        if ($partition === null || (is_array($partition) && count($partition) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $partition when calling getTweetsSample10Stream'
            );
        }

        $resourcePath = '/2/tweets/sample10/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($backfill_minutes !== null) {
            $queryParams['backfill_minutes'] = ObjectSerializer::toQueryValue($backfill_minutes, 'int32');
        }
        // query params
        if ($partition !== null) {
            $queryParams['partition'] = ObjectSerializer::toQueryValue($partition, 'int32');
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideReplyById
     *
     * Hide replies
     *
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \Swagger\Client\Model\TweetHideRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TweetHideResponse
     */
    public function hideReplyById($tweet_id, $body = null)
    {
        list($response) = $this->hideReplyByIdWithHttpInfo($tweet_id, $body);
        return $response;
    }

    /**
     * Operation hideReplyByIdWithHttpInfo
     *
     * Hide replies
     *
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \Swagger\Client\Model\TweetHideRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TweetHideResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideReplyByIdWithHttpInfo($tweet_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\TweetHideResponse';
        $request = $this->hideReplyByIdRequest($tweet_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TweetHideResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation hideReplyByIdAsync
     *
     * Hide replies
     *
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \Swagger\Client\Model\TweetHideRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideReplyByIdAsync($tweet_id, $body = null)
    {
        return $this->hideReplyByIdAsyncWithHttpInfo($tweet_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideReplyByIdAsyncWithHttpInfo
     *
     * Hide replies
     *
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \Swagger\Client\Model\TweetHideRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideReplyByIdAsyncWithHttpInfo($tweet_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\TweetHideResponse';
        $request = $this->hideReplyByIdRequest($tweet_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideReplyById'
     *
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \Swagger\Client\Model\TweetHideRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function hideReplyByIdRequest($tweet_id, $body = null)
    {
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling hideReplyById'
            );
        }

        $resourcePath = '/2/tweets/{tweet_id}/hidden';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tweet_id' . '}',
                ObjectSerializer::toPathValue($tweet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listsIdTweets
     *
     * List Tweets timeline by List ID.
     *
     * @param  \Swagger\Client\Model\ListId $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2ListsIdTweetsResponse
     */
    public function listsIdTweets($id, $max_results = '100', $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->listsIdTweetsWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation listsIdTweetsWithHttpInfo
     *
     * List Tweets timeline by List ID.
     *
     * @param  \Swagger\Client\Model\ListId $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2ListsIdTweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listsIdTweetsWithHttpInfo($id, $max_results = '100', $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2ListsIdTweetsResponse';
        $request = $this->listsIdTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2ListsIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listsIdTweetsAsync
     *
     * List Tweets timeline by List ID.
     *
     * @param  \Swagger\Client\Model\ListId $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listsIdTweetsAsync($id, $max_results = '100', $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->listsIdTweetsAsyncWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listsIdTweetsAsyncWithHttpInfo
     *
     * List Tweets timeline by List ID.
     *
     * @param  \Swagger\Client\Model\ListId $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listsIdTweetsAsyncWithHttpInfo($id, $max_results = '100', $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2ListsIdTweetsResponse';
        $request = $this->listsIdTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listsIdTweets'
     *
     * @param  \Swagger\Client\Model\ListId $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listsIdTweetsRequest($id, $max_results = '100', $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling listsIdTweets'
            );
        }

        $resourcePath = '/2/lists/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sampleStream
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamingTweetResponse
     */
    public function sampleStream($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->sampleStreamWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation sampleStreamWithHttpInfo
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamingTweetResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sampleStreamWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\StreamingTweetResponse';
        $request = $this->sampleStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamingTweetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sampleStreamAsync
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sampleStreamAsync($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->sampleStreamAsyncWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sampleStreamAsyncWithHttpInfo
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sampleStreamAsyncWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\StreamingTweetResponse';
        $request = $this->sampleStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sampleStream'
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sampleStreamRequest($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {

        $resourcePath = '/2/tweets/sample/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($backfill_minutes !== null) {
            $queryParams['backfill_minutes'] = ObjectSerializer::toQueryValue($backfill_minutes, 'int32');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStream
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FilteredStreamingTweetResponse
     */
    public function searchStream($backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->searchStreamWithHttpInfo($backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation searchStreamWithHttpInfo
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FilteredStreamingTweetResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchStreamWithHttpInfo($backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\FilteredStreamingTweetResponse';
        $request = $this->searchStreamRequest($backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FilteredStreamingTweetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchStreamAsync
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStreamAsync($backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->searchStreamAsyncWithHttpInfo($backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStreamAsyncWithHttpInfo
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStreamAsyncWithHttpInfo($backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\FilteredStreamingTweetResponse';
        $request = $this->searchStreamRequest($backfill_minutes, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchStream'
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchStreamRequest($backfill_minutes = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {

        $resourcePath = '/2/tweets/search/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($backfill_minutes !== null) {
            $queryParams['backfill_minutes'] = ObjectSerializer::toQueryValue($backfill_minutes, 'int32');
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation spaceBuyers
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  \Swagger\Client\Model\PaginationToken32 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2SpacesIdBuyersResponse
     */
    public function spaceBuyers($id, $pagination_token = null, $max_results = '100', $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        list($response) = $this->spaceBuyersWithHttpInfo($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);
        return $response;
    }

    /**
     * Operation spaceBuyersWithHttpInfo
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  \Swagger\Client\Model\PaginationToken32 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2SpacesIdBuyersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function spaceBuyersWithHttpInfo($id, $pagination_token = null, $max_results = '100', $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2SpacesIdBuyersResponse';
        $request = $this->spaceBuyersRequest($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2SpacesIdBuyersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation spaceBuyersAsync
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  \Swagger\Client\Model\PaginationToken32 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceBuyersAsync($id, $pagination_token = null, $max_results = '100', $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        return $this->spaceBuyersAsyncWithHttpInfo($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation spaceBuyersAsyncWithHttpInfo
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  \Swagger\Client\Model\PaginationToken32 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceBuyersAsyncWithHttpInfo($id, $pagination_token = null, $max_results = '100', $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2SpacesIdBuyersResponse';
        $request = $this->spaceBuyersRequest($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'spaceBuyers'
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  \Swagger\Client\Model\PaginationToken32 $pagination_token This parameter is used to get a specified &#x27;page&#x27; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function spaceBuyersRequest($id, $pagination_token = null, $max_results = '100', $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling spaceBuyers'
            );
        }

        $resourcePath = '/2/spaces/{id}/buyers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation spaceTweets
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2SpacesIdTweetsResponse
     */
    public function spaceTweets($id, $max_results = '100', $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->spaceTweetsWithHttpInfo($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation spaceTweetsWithHttpInfo
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2SpacesIdTweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function spaceTweetsWithHttpInfo($id, $max_results = '100', $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2SpacesIdTweetsResponse';
        $request = $this->spaceTweetsRequest($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2SpacesIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation spaceTweetsAsync
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceTweetsAsync($id, $max_results = '100', $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->spaceTweetsAsyncWithHttpInfo($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation spaceTweetsAsyncWithHttpInfo
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceTweetsAsyncWithHttpInfo($id, $max_results = '100', $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2SpacesIdTweetsResponse';
        $request = $this->spaceTweetsRequest($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'spaceTweets'
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function spaceTweetsRequest($id, $max_results = '100', $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling spaceTweets'
            );
        }

        $resourcePath = '/2/spaces/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetCountsFullArchiveSearch
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsCountsAllResponse
     */
    public function tweetCountsFullArchiveSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        list($response) = $this->tweetCountsFullArchiveSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);
        return $response;
    }

    /**
     * Operation tweetCountsFullArchiveSearchWithHttpInfo
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsCountsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetCountsFullArchiveSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsCountsAllResponse';
        $request = $this->tweetCountsFullArchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsCountsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetCountsFullArchiveSearchAsync
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsFullArchiveSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        return $this->tweetCountsFullArchiveSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetCountsFullArchiveSearchAsyncWithHttpInfo
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsFullArchiveSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsCountsAllResponse';
        $request = $this->tweetCountsFullArchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetCountsFullArchiveSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetCountsFullArchiveSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetCountsFullArchiveSearch'
            );
        }

        $resourcePath = '/2/tweets/counts/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($next_token !== null) {
            $queryParams['next_token'] = ObjectSerializer::toQueryValue($next_token, null);
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($granularity !== null) {
            $queryParams['granularity'] = ObjectSerializer::toQueryValue($granularity, null);
        }
        // query params
        if (is_array($search_count_fields)) {
            $search_count_fields = ObjectSerializer::serializeCollection($search_count_fields, 'csv', true);
        }
        if ($search_count_fields !== null) {
            $queryParams['search_count.fields'] = ObjectSerializer::toQueryValue($search_count_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetCountsRecentSearch
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsCountsRecentResponse
     */
    public function tweetCountsRecentSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        list($response) = $this->tweetCountsRecentSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);
        return $response;
    }

    /**
     * Operation tweetCountsRecentSearchWithHttpInfo
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsCountsRecentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetCountsRecentSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsCountsRecentResponse';
        $request = $this->tweetCountsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsCountsRecentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetCountsRecentSearchAsync
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsRecentSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        return $this->tweetCountsRecentSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetCountsRecentSearchAsyncWithHttpInfo
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsRecentSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsCountsRecentResponse';
        $request = $this->tweetCountsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetCountsRecentSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to hour)
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetCountsRecentSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetCountsRecentSearch'
            );
        }

        $resourcePath = '/2/tweets/counts/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($next_token !== null) {
            $queryParams['next_token'] = ObjectSerializer::toQueryValue($next_token, null);
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($granularity !== null) {
            $queryParams['granularity'] = ObjectSerializer::toQueryValue($granularity, null);
        }
        // query params
        if (is_array($search_count_fields)) {
            $search_count_fields = ObjectSerializer::serializeCollection($search_count_fields, 'csv', true);
        }
        if ($search_count_fields !== null) {
            $queryParams['search_count.fields'] = ObjectSerializer::toQueryValue($search_count_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetsFullarchiveSearch
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsSearchAllResponse
     */
    public function tweetsFullarchiveSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->tweetsFullarchiveSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation tweetsFullarchiveSearchWithHttpInfo
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsSearchAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetsFullarchiveSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSearchAllResponse';
        $request = $this->tweetsFullarchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsSearchAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetsFullarchiveSearchAsync
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsFullarchiveSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->tweetsFullarchiveSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetsFullarchiveSearchAsyncWithHttpInfo
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsFullarchiveSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSearchAllResponse';
        $request = $this->tweetsFullarchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetsFullarchiveSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetsFullarchiveSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetsFullarchiveSearch'
            );
        }

        $resourcePath = '/2/tweets/search/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($next_token !== null) {
            $queryParams['next_token'] = ObjectSerializer::toQueryValue($next_token, null);
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sort_order'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetsRecentSearch
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2TweetsSearchRecentResponse
     */
    public function tweetsRecentSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->tweetsRecentSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation tweetsRecentSearchWithHttpInfo
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2TweetsSearchRecentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetsRecentSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSearchRecentResponse';
        $request = $this->tweetsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2TweetsSearchRecentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetsRecentSearchAsync
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsRecentSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->tweetsRecentSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetsRecentSearchAsyncWithHttpInfo
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsRecentSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2TweetsSearchRecentResponse';
        $request = $this->tweetsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetsRecentSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  \Swagger\Client\Model\TweetId $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  \Swagger\Client\Model\PaginationToken36 $next_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetsRecentSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = '10', $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetsRecentSearch'
            );
        }

        $resourcePath = '/2/tweets/search/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($next_token !== null) {
            $queryParams['next_token'] = ObjectSerializer::toQueryValue($next_token, null);
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sort_order'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdLike
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersLikesCreateRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UsersLikesCreateResponse
     */
    public function usersIdLike($id, $body = null)
    {
        list($response) = $this->usersIdLikeWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation usersIdLikeWithHttpInfo
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersLikesCreateRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UsersLikesCreateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdLikeWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\UsersLikesCreateResponse';
        $request = $this->usersIdLikeRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UsersLikesCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdLikeAsync
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersLikesCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikeAsync($id, $body = null)
    {
        return $this->usersIdLikeAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdLikeAsyncWithHttpInfo
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersLikesCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikeAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\UsersLikesCreateResponse';
        $request = $this->usersIdLikeRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdLike'
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersLikesCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdLikeRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdLike'
            );
        }

        $resourcePath = '/2/users/{id}/likes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdLikedTweets
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2UsersIdLikedTweetsResponse
     */
    public function usersIdLikedTweets($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdLikedTweetsWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdLikedTweetsWithHttpInfo
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2UsersIdLikedTweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdLikedTweetsWithHttpInfo($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdLikedTweetsResponse';
        $request = $this->usersIdLikedTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2UsersIdLikedTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdLikedTweetsAsync
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikedTweetsAsync($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdLikedTweetsAsyncWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdLikedTweetsAsyncWithHttpInfo
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikedTweetsAsyncWithHttpInfo($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdLikedTweetsResponse';
        $request = $this->usersIdLikedTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdLikedTweets'
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdLikedTweetsRequest($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdLikedTweets'
            );
        }

        $resourcePath = '/2/users/{id}/liked_tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdMentions
     *
     * User mention timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2UsersIdMentionsResponse
     */
    public function usersIdMentions($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdMentionsWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdMentionsWithHttpInfo
     *
     * User mention timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2UsersIdMentionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdMentionsWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdMentionsResponse';
        $request = $this->usersIdMentionsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2UsersIdMentionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdMentionsAsync
     *
     * User mention timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdMentionsAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdMentionsAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdMentionsAsyncWithHttpInfo
     *
     * User mention timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdMentionsAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdMentionsResponse';
        $request = $this->usersIdMentionsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdMentions'
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdMentionsRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdMentions'
            );
        }

        $resourcePath = '/2/users/{id}/mentions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdRetweets
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersRetweetsCreateRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UsersRetweetsCreateResponse
     */
    public function usersIdRetweets($id, $body = null)
    {
        list($response) = $this->usersIdRetweetsWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation usersIdRetweetsWithHttpInfo
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersRetweetsCreateRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UsersRetweetsCreateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdRetweetsWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\UsersRetweetsCreateResponse';
        $request = $this->usersIdRetweetsRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UsersRetweetsCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdRetweetsAsync
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersRetweetsCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdRetweetsAsync($id, $body = null)
    {
        return $this->usersIdRetweetsAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdRetweetsAsyncWithHttpInfo
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersRetweetsCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdRetweetsAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\UsersRetweetsCreateResponse';
        $request = $this->usersIdRetweetsRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdRetweets'
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\UsersRetweetsCreateRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdRetweetsRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdRetweets'
            );
        }

        $resourcePath = '/2/users/{id}/retweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdTimeline
     *
     * User home timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse
     */
    public function usersIdTimeline($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdTimelineWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdTimelineWithHttpInfo
     *
     * User home timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdTimelineWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse';
        $request = $this->usersIdTimelineRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdTimelineAsync
     *
     * User home timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTimelineAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdTimelineAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdTimelineAsyncWithHttpInfo
     *
     * User home timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTimelineAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse';
        $request = $this->usersIdTimelineRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdTimeline'
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdTimelineRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdTimeline'
            );
        }

        $resourcePath = '/2/users/{id}/timelines/reverse_chronological';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'csv', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdTweets
     *
     * User Tweets timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Get2UsersIdTweetsResponse
     */
    public function usersIdTweets($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdTweetsWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdTweetsWithHttpInfo
     *
     * User Tweets timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Get2UsersIdTweetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdTweetsWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdTweetsResponse';
        $request = $this->usersIdTweetsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Get2UsersIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdTweetsAsync
     *
     * User Tweets timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTweetsAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdTweetsAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdTweetsAsyncWithHttpInfo
     *
     * User Tweets timeline by User ID
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTweetsAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\Swagger\Client\Model\Get2UsersIdTweetsResponse';
        $request = $this->usersIdTweetsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdTweets'
     *
     * @param  \Swagger\Client\Model\UserId $id The ID of the User to lookup. (required)
     * @param  \Swagger\Client\Model\TweetId $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  \Swagger\Client\Model\TweetId $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  \Swagger\Client\Model\PaginationToken36 $pagination_token This parameter is used to get the next &#x27;page&#x27; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#x27;replies&#x27; or &#x27;retweets&#x27;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdTweetsRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdTweets'
            );
        }

        $resourcePath = '/2/users/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since_id !== null) {
            $queryParams['since_id'] = ObjectSerializer::toQueryValue($since_id, null);
        }
        // query params
        if ($until_id !== null) {
            $queryParams['until_id'] = ObjectSerializer::toQueryValue($until_id, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['max_results'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($pagination_token !== null) {
            $queryParams['pagination_token'] = ObjectSerializer::toQueryValue($pagination_token, null);
        }
        // query params
        if (is_array($exclude)) {
            $exclude = ObjectSerializer::serializeCollection($exclude, 'csv', true);
        }
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude, null);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time, 'date-time');
        }
        // query params
        if ($end_time !== null) {
            $queryParams['end_time'] = ObjectSerializer::toQueryValue($end_time, 'date-time');
        }
        // query params
        if (is_array($tweet_fields)) {
            $tweet_fields = ObjectSerializer::serializeCollection($tweet_fields, 'csv', true);
        }
        if ($tweet_fields !== null) {
            $queryParams['tweet.fields'] = ObjectSerializer::toQueryValue($tweet_fields, null);
        }
        // query params
        if (is_array($expansions)) {
            $expansions = ObjectSerializer::serializeCollection($expansions, 'csv', true);
        }
        if ($expansions !== null) {
            $queryParams['expansions'] = ObjectSerializer::toQueryValue($expansions, null);
        }
        // query params
        if (is_array($media_fields)) {
            $media_fields = ObjectSerializer::serializeCollection($media_fields, 'csv', true);
        }
        if ($media_fields !== null) {
            $queryParams['media.fields'] = ObjectSerializer::toQueryValue($media_fields, null);
        }
        // query params
        if (is_array($poll_fields)) {
            $poll_fields = ObjectSerializer::serializeCollection($poll_fields, 'csv', true);
        }
        if ($poll_fields !== null) {
            $queryParams['poll.fields'] = ObjectSerializer::toQueryValue($poll_fields, null);
        }
        // query params
        if (is_array($user_fields)) {
            $user_fields = ObjectSerializer::serializeCollection($user_fields, 'csv', true);
        }
        if ($user_fields !== null) {
            $queryParams['user.fields'] = ObjectSerializer::toQueryValue($user_fields, null);
        }
        // query params
        if (is_array($place_fields)) {
            $place_fields = ObjectSerializer::serializeCollection($place_fields, 'csv', true);
        }
        if ($place_fields !== null) {
            $queryParams['place.fields'] = ObjectSerializer::toQueryValue($place_fields, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdUnlike
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UsersLikesDeleteResponse
     */
    public function usersIdUnlike($id, $tweet_id)
    {
        list($response) = $this->usersIdUnlikeWithHttpInfo($id, $tweet_id);
        return $response;
    }

    /**
     * Operation usersIdUnlikeWithHttpInfo
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UsersLikesDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdUnlikeWithHttpInfo($id, $tweet_id)
    {
        $returnType = '\Swagger\Client\Model\UsersLikesDeleteResponse';
        $request = $this->usersIdUnlikeRequest($id, $tweet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UsersLikesDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdUnlikeAsync
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnlikeAsync($id, $tweet_id)
    {
        return $this->usersIdUnlikeAsyncWithHttpInfo($id, $tweet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdUnlikeAsyncWithHttpInfo
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnlikeAsyncWithHttpInfo($id, $tweet_id)
    {
        $returnType = '\Swagger\Client\Model\UsersLikesDeleteResponse';
        $request = $this->usersIdUnlikeRequest($id, $tweet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdUnlike'
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdUnlikeRequest($id, $tweet_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdUnlike'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling usersIdUnlike'
            );
        }

        $resourcePath = '/2/users/{id}/likes/{tweet_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tweet_id' . '}',
                ObjectSerializer::toPathValue($tweet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdUnretweets
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UsersRetweetsDeleteResponse
     */
    public function usersIdUnretweets($id, $source_tweet_id)
    {
        list($response) = $this->usersIdUnretweetsWithHttpInfo($id, $source_tweet_id);
        return $response;
    }

    /**
     * Operation usersIdUnretweetsWithHttpInfo
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UsersRetweetsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdUnretweetsWithHttpInfo($id, $source_tweet_id)
    {
        $returnType = '\Swagger\Client\Model\UsersRetweetsDeleteResponse';
        $request = $this->usersIdUnretweetsRequest($id, $source_tweet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UsersRetweetsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdUnretweetsAsync
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnretweetsAsync($id, $source_tweet_id)
    {
        return $this->usersIdUnretweetsAsyncWithHttpInfo($id, $source_tweet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdUnretweetsAsyncWithHttpInfo
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnretweetsAsyncWithHttpInfo($id, $source_tweet_id)
    {
        $returnType = '\Swagger\Client\Model\UsersRetweetsDeleteResponse';
        $request = $this->usersIdUnretweetsRequest($id, $source_tweet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdUnretweets'
     *
     * @param  \Swagger\Client\Model\UserIdMatchesAuthenticatedUser $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \Swagger\Client\Model\TweetId $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersIdUnretweetsRequest($id, $source_tweet_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdUnretweets'
            );
        }
        // verify the required parameter 'source_tweet_id' is set
        if ($source_tweet_id === null || (is_array($source_tweet_id) && count($source_tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_tweet_id when calling usersIdUnretweets'
            );
        }

        $resourcePath = '/2/users/{id}/retweets/{source_tweet_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($source_tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'source_tweet_id' . '}',
                ObjectSerializer::toPathValue($source_tweet_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
